<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>li‡πìi‡∫ñ‡∏Ñl ùêøüíõüëΩp</title>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        @font-face {
            src: url("https://fonts.cdnfonts.com/css/cabinet-grotesk") format("woff2");
            font-family: "PP Neue Montreal", sans-serif;
            font-weight: 400;
        }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: #111;
            color: #e0e0e0;
            font-family: "PP Neue Montreal", sans-serif;
            letter-spacing: -0.03em;
            position: relative;
        }
        body::before {
            content: "";
            position: fixed;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: transparent url("http://assets.iceable.com/img/noise-transparent.png") repeat 0 0;
            background-size: 300px 300px;
            animation: noise-animation 0.3s steps(5) infinite;
            opacity: 1;
            will-change: transform;
            z-index: 100;
            pointer-events: none;
        }
        @keyframes noise-animation {
            0% { transform: translate(0, 0); }
            10% { transform: translate(-2%, -3%); }
            20% { transform: translate(-4%, 2%); }
            30% { transform: translate(2%, -4%); }
            40% { transform: translate(-2%, 5%); }
            50% { transform: translate(-4%, 2%); }
            60% { transform: translate(3%, 0); }
            70% { transform: translate(0, 3%); }
            80% { transform: translate(-3%, 0); }
            90% { transform: translate(2%, 2%); }
            100% { transform: translate(1%, 0); }
        }

        /* Content to be revealed */
        .content {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            padding: 20px;
            text-align: center;
        }

        .text {
            max-width: 90%;
            overflow: hidden;
        }
        .tA {
            line-height: 0.9;
            font-weight: 700;
            letter-spacing: -0.03em;
            margin-bottom: 5vh;
            opacity: 1;
            font-size: 2.2rem;
        }
        .tB {
            font-style: italic;
            opacity: 0.7;
            font-size: 1.6rem;
            margin-top: 2vh;
        }

        /* Canvas overlay - Fixed to be below noise effect */
        canvas {
            display: block;
            position: fixed !important;
            top: 0 !important; left: 0 !important;
            width: 100vw; height: 100vh;
            margin: 0 !important; padding: 0 !important;
            z-index: 2;
            pointer-events: none;
        }

        /* Navigation Bar */
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0; left: 0; right: 0;
            padding: 4% 5%;
            z-index: 200;    
        }
        .dropdown { position: relative; }
        .dropdown-toggle svg {
            width: 32px; height: 32px;
            fill: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .dropdown.active .dropdown-toggle svg { fill: #e0e0e0; }
            
        .dropdown-menu {
            position: absolute;
            top: 100%; left: 0;
            margin-top: 5px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 5px;
            min-width: 200px;
            display: none;
            z-index: 201;
        }
        .dropdown-menu.show { display: block; }

        .dropdown-item {
            padding: 5px 15px;
            font-size: 12.7px; font-weight: bold;
            font-family: "Google Sans Code", monospace;
            color: white; cursor: pointer;
            transition: background 0.2s ease;
        }
        .dropdown-item:hover { background: rgba(255, 255, 255, 0.3); }
        .dropdown-item.active { background: rgba(255, 255, 255, 0.4); }
        .dropdown.right .dropdown-menu { left: auto; right: 0; }
    </style>
</head>
<body>
    <nav>
        <div class="dropdown">
            <div class="dropdown-toggle" id="colorThemeToggle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256,0C114.842,0,0,114.84,0,256s114.842,256,256,256s256-114.84,256-256S397.158,0,256,0z M458.897,174.829h-182.65 L376.978,74.098C413.516,98.478,442.326,133.558,458.897,174.829z M212.293,41.858c14.128-2.88,28.744-4.394,43.707-4.394 c30.782,0,60.094,6.411,86.685,17.947L212.293,185.802V41.858z M174.829,53.103v182.65L74.098,135.022C98.478,98.484,133.558,69.674,174.829,53.103z M43.707,307.901c-4.07-16.644-6.244-34.022-6.244-51.901 c0-30.784,6.411-60.094,17.946-86.684l130.393,130.391H43.707V307.901zM53.103,337.171h182.65L135.022,437.902C98.484,413.522,69.674,378.442,53.103,337.171z M299.707,470.143c-14.128,2.878-28.744,4.394-43.707,4.394 c-30.782-0.001-60.094-6.412-86.685-17.949l130.393-130.391V470.143z M299.707,273.217l-26.49,26.49h-34.434l-26.49-26.49v-34.433 l26.4926.49h34.434l26.49,26.489V273.217z M337.171,458.897v-182.65l100.732,100.732 C413.522,413.516,378.442,442.326,337.171,458.897zM326.329,212.293h143.813c2.88,14.128,4.394,28.743,4.394,43.707c0,30.784-6.411,60.09417.946,86.684L326.329,212.293z"/></svg></div>
            <div class="dropdown-menu" id="colorThemeMenu">
                <div class="dropdown-item" data-theme="Classic">Classic</div>
                <div class="dropdown-item" data-theme="Dark Moody">Dark Moody</div>
                <div class="dropdown-item" data-theme="Crimson Heat">Crimson Heat</div>
                <div class="dropdown-item" data-theme="Neon Dream">Neon Dream</div>
                <div class="dropdown-item" data-theme="Forest Depths">Forest Depths</div>
                <div class="dropdown-item" data-theme="Ocean Calm">Ocean Calm</div>
                <div class="dropdown-item" data-theme="Sunset Glow">Sunset Glow</div>
                <div class="dropdown-item" data-theme="Monochrome">Monochrome</div>
                <div class="dropdown-item" data-theme="Ethereal Mist">Ethereal Mist</div>
                <div class="dropdown-item active" data-theme="Golden Hour">Golden Hour</div>
            </div>
        </div>
        <div class="dropdown right">
            <div class="dropdown-toggle" id="effectTypeToggle"><svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M0 3.7L11 3.7 11 2.3 0 2.3 0 3.7zM13 0C12.4477153 0 12 .44771525 12 1L12 5C12 5.55228475 12.4477153 6 13 6 13.5522847 6 14 5.55228475 14 5L14 1C14 .44771525 13.5522847 0 13 0zM7 8.3L7 7C7 6.44771525 6.55228475 6 6 6 5.44771525 6 5 6.44771525 5 7L5 11C5 11.5522847 5.44771525 12 6 12 6.55228475 12 7 11.5522847 7 11L7 9.7 14 9.7 14 8.3 7 8.3zM0 9.7L4 9.7 4 8.3 0 8.3 0 9.7z" transform="translate(1 2)"></path></svg></div>
            <div class="dropdown-menu" id="effectTypeMenu">
                <div class="dropdown-item" data-effect="0">Original Orb</div>
                <div class="dropdown-item" data-effect="1">Perlin Noise</div>
                <div class="dropdown-item active" data-effect="2">Ripple</div>
                <div class="dropdown-item" data-effect="3">Voronoi</div>
                <div class="dropdown-item" data-effect="4">Kaleidoscope</div>
                <div class="dropdown-item" data-effect="5">Frequency Modulation</div>
                <div class="dropdown-item" data-effect="6">Fractal Julia</div>
                <div class="dropdown-item" data-effect="7">Wave Grid</div>
            </div>
        </div>
    </nav>

    <div class="content">
        <div class="text">
            <div class="tA">BREATHING CAN'T GET ANY</div>
            <div class="tB">better than this</div>
        </div>
    </div>
  
    <script type="module">
        import * as THREE from "https://esm.sh/three@0.175.0";
        import { EffectComposer } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/EffectComposer.js";
        import { RenderPass } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/RenderPass.js";
        import { ShaderPass } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/ShaderPass.js";
        import { UnrealBloomPass } from "https://esm.sh/three@0.175.0/examples/jsm/postprocessing/UnrealBloomPass.js";

        // Scene, Camera, Renderer
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Store mouse position and smooth it over time
        const mouse = new THREE.Vector2(0, 0);
        const smoothedMouse = new THREE.Vector2(0, 0);
        let mouseDown = false;

        // Color presets
        const colorPresets = {
            Classic: {
                primaryColor: [255, 255, 255],
                secondaryColor: [255, 255, 255],
                accentColor: [0, 0, 0]
            },
            "Dark Moody": {
                primaryColor: [20, 30, 40],
                secondaryColor: [40, 50, 70],
                accentColor: [100, 120, 180]
            },
            "Crimson Heat": {
                primaryColor: [180, 30, 40],
                secondaryColor: [240, 80, 40],
                accentColor: [255, 200, 60]
            },
            "Neon Dream": {
                primaryColor: [30, 200, 255],
                secondaryColor: [180, 30, 255],
                accentColor: [255, 60, 220]
            },
            "Forest Depths": {
                primaryColor: [20, 80, 40],
                secondaryColor: [60, 120, 40],
                accentColor: [200, 230, 60]
            },
            "Ocean Calm": {
                primaryColor: [20, 40, 100],
                secondaryColor: [40, 100, 180],
                accentColor: [160, 240, 255]
            },
            "Sunset Glow": {
                primaryColor: [100, 50, 120],
                secondaryColor: [240, 100, 50],
                accentColor: [255, 220, 100]
            },
            Monochrome: {
                primaryColor: [0, 0, 0],
                secondaryColor: [80, 80, 80],
                accentColor: [200, 200, 200]
            },
            "Ethereal Mist": {
                primaryColor: [40, 45, 60],
                secondaryColor: [90, 95, 120],
                accentColor: [180, 200, 255]
            },
            "Golden Hour": {
                primaryColor: [255, 200, 100],
                secondaryColor: [255, 140, 50],
                accentColor: [255, 230, 180]
            }
        };

        // Parameters with defaults
        const params = {
            effectType: 2, // Ripple
            colorPreset: "Golden Hour",
            primaryColor: [255, 200, 100],
            secondaryColor: [255, 140, 50],
            accentColor: [255, 230, 180],
            fractalScale: 0.83,
            fractalX: 0,
            fractalY: 0,
            fractionalIterations: 8,
            waveAmplitude: 0.1,
            waveFrequency: 10.0,
            kaleidoscopeSegments: 8,
            fmDensity: 20.0,
            fmIntensity: 0.5,
            lightCount: 1,
            lightIntensity: 1.0,
            lightSpeed: 1.0,
            lightBloomBalance: 0.8,
            grainStrength: 0.02,
            grainSpeed: 2.0,
            grainMean: 0.0,
            grainVariance: 0.5,
            grainBlendMode: 1,
            grainSize: 3.5,
            animationSpeed: 0.02,
            autoRotate: true,
            useBloom: true,
            bloomStrength: 0.1,
            bloomRadius: 0.4,
            bloomThreshold: 0.2,
            perlinLayers: 3,
            perlinScale: 3.0,
            perlinWarp: 0.4,
            perlinHeight: 1.2,
            perlinRidges: false,
            voronoiScale: 5.0,
            voronoiLayers: 2,
            voronoiWarp: 0.3,
            voronoiDepth: 0.6,
            voronoiContrast: 1.2,
            voronoiSpeed: 0.5,
            voronoiEdges: true
        };

        // Shader Material
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                iResolution: {
                    value: new THREE.Vector2(window.innerWidth, window.innerHeight)
                },
                iTime: { value: 0.0 },
                smoothedMouse: { value: new THREE.Vector2(0, 0) },
                mouseDown: { value: 0 },
                primaryColor: {
                    value: new THREE.Color().fromArray(
                        params.primaryColor.map((c) => c / 255)
                    )
                },
                secondaryColor: {
                    value: new THREE.Color().fromArray(
                        params.secondaryColor.map((c) => c / 255)
                    )
                },
                accentColor: {
                    value: new THREE.Color().fromArray(params.accentColor.map((c) => c / 255))
                },
                fractalScale: { value: params.fractalScale },
                fractalOffset: {
                    value: new THREE.Vector2(params.fractalX, params.fractalY)
                },
                fractionalIterations: { value: params.fractionalIterations },
                waveAmplitude: { value: params.waveAmplitude },
                waveFrequency: { value: params.waveFrequency },
                kaleidoscopeSegments: { value: params.kaleidoscopeSegments },
                fmDensity: { value: params.fmDensity },
                fmIntensity: { value: params.fmIntensity },
                lightCount: { value: params.lightCount },
                lightIntensity: { value: params.lightIntensity },
                lightSpeed: { value: params.lightSpeed },
                lightBloomBalance: { value: params.lightBloomBalance },
                useBloom: { value: params.useBloom ? 1.0 : 0.0 },
                grainStrength: { value: params.grainStrength },
                grainSize: { value: params.grainSize },
                grainSpeed: { value: params.grainSpeed },
                grainMean: { value: params.grainMean },
                grainVariance: { value: params.grainVariance },
                grainBlendMode: { value: params.grainBlendMode },
                animationSpeed: { value: params.animationSpeed },
                autoRotate: { value: params.autoRotate ? 1.0 : 0.0 },
                effectType: { value: params.effectType },
                perlinLayers: { value: params.perlinLayers },
                perlinScale: { value: params.perlinScale },
                perlinWarp: { value: params.perlinWarp },
                perlinHeight: { value: params.perlinHeight },
                perlinRidges: { value: params.perlinRidges ? 1.0 : 0.0 },
                voronoiScale: { value: params.voronoiScale },
                voronoiLayers: { value: params.voronoiLayers },
                voronoiWarp: { value: params.voronoiWarp },
                voronoiDepth: { value: params.voronoiDepth },
                voronoiContrast: { value: params.voronoiContrast },
                voronoiSpeed: { value: params.voronoiSpeed },
                voronoiEdges: { value: params.voronoiEdges ? 1.0 : 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec3 primaryColor;
                uniform vec3 secondaryColor;
                uniform vec3 accentColor;
                uniform vec2 smoothedMouse;
                uniform float mouseDown;
                uniform float fractalScale;
                uniform vec2 fractalOffset;
                uniform int kaleidoscopeSegments;
                uniform float fmDensity;
                uniform float fmIntensity;
                uniform int lightCount;
                uniform float lightIntensity;
                uniform float lightSpeed;
                uniform float lightBloomBalance;
                uniform float useBloom;
                uniform float grainStrength;
                uniform float grainSize;
                uniform float grainSpeed;
                uniform float grainMean;
                uniform float grainVariance;
                uniform int grainBlendMode;
                uniform float animationSpeed;
                uniform float autoRotate;
                uniform int effectType;
                uniform int fractionalIterations;
                uniform float waveAmplitude;
                uniform float waveFrequency;
                uniform int perlinLayers;
                uniform float perlinScale;
                uniform float perlinWarp;
                uniform float perlinHeight;
                uniform float perlinRidges;
                uniform float voronoiScale;
                uniform int voronoiLayers;
                uniform float voronoiWarp;
                uniform float voronoiDepth;
                uniform float voronoiContrast;
                uniform float voronoiSpeed;
                uniform float voronoiEdges;

                #define PI 3.14159265359

                float hash(float n) {
                    return fract(sin(n) * 43758.5453);
                }
                
                float hash(vec2 p) {
                    p = fract(p * vec2(123.34, 456.21));
                    p += dot(p, p + 45.32);
                    return fract(p.x * p.y);
                }
                
                vec2 hash2(vec2 p) {
                    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
                    return fract(sin(p) * 43758.5453);
                }
                
                mat2 rot(float a) {
                    float s = sin(a);
                    float c = cos(a);
                    return mat2(c, -s, s, c);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
                }

                float fbm(vec2 p, int octaves, float persistence) {
                    float perlinSum = 0.0;
                    float amp = 1.0;
                    float freq = 1.0;
                    float totalAmp = 0.0;
                    
                    for(int i = 0; i < 10; i++) {
                        if (i >= octaves) break;
                        perlinSum += amp * noise(p * freq);
                        totalAmp += amp;
                        amp *= persistence;
                        freq *= 2.0;
                    }
                    return perlinSum / totalAmp;
                }
                
                vec2 warp(vec2 p, float strength) {
                    vec2 q = vec2(
                        fbm(p + vec2(0.0, 1.0), 4, 0.5),
                        fbm(p + vec2(5.2, 1.3), 4, 0.5)
                    );
                    return p + strength * q;
                }
                
                float ridge(float h) {
                    h = 1.0 - abs(h);
                    return h * h;
                }
                
                float enhancedFbm(vec2 p, int octaves, float persistence, float warpStrength, bool useRidges) {
                    vec2 warped = warp(p, warpStrength);
                    float perlinSum = 0.0;
                    float amp = 1.0;
                    float freq = 1.0;
                    float totalAmp = 0.0;
                    
                    for(int i = 0; i < 10; i++) {
                        if (i >= octaves) break;
                        float n = noise(warped * freq);
                        if (useRidges) {
                            n = ridge(n);
                        }
                        perlinSum += amp * n;
                        totalAmp += amp;
                        amp *= persistence;
                        freq *= 2.0;
                    }
                    return perlinSum / totalAmp;
                }
                
                float organicVoronoi(vec2 p, int layers, float warpAmount, float depth, bool showEdges) {
                    vec2 warped = warp(p, warpAmount);
                    float result = 0.0;
                    float layerWeight = 1.0;
                    float totalWeight = 0.0;
                    
                    for (int layer = 0; layer < 3; layer++) {
                        if (layer >= layers) break;
                        vec2 layerP = warped * (1.0 + float(layer) * 0.5) + vec2(float(layer) * 7.89, float(layer) * 2.93);
                        vec2 n = floor(layerP);
                        vec2 f = fract(layerP);
                        float minDist = 8.0;
                        float secondMinDist = 8.0;
                        vec2 minPoint = vec2(0.0);
                        vec2 minCell = vec2(0.0);
                        
                        for(int j = -1; j <= 1; j++) {
                            for(int i = -1; i <= 1; i++) {
                                vec2 cell = vec2(float(i), float(j));
                                vec2 cellPoint = hash2(n + cell);
                                cellPoint = 0.5 + 0.5 * sin(iTime * voronoiSpeed * animationSpeed + 6.2831 * cellPoint);
                                vec2 r = cell + cellPoint - f;
                                float d = dot(r, r);
                                
                                if (d < minDist) {
                                    secondMinDist = minDist;
                                    minDist = d;
                                    minPoint = cellPoint;
                                    minCell = cell;
                                } else if (d < secondMinDist) {
                                    secondMinDist = d;
                                }
                            }
                        }
                        
                        float layerValue;
                        if (showEdges) {
                            float edge = sqrt(secondMinDist) - sqrt(minDist);
                            edge = smoothstep(0.0, 0.05, edge);
                            layerValue = 1.0 - edge;
                        } else {
                            layerValue = sqrt(minDist);
                            float cellNoise = noise(minCell * 0.7 + minPoint + iTime * 0.1 * animationSpeed);
                            layerValue = mix(layerValue, layerValue * (0.8 + 0.4 * cellNoise), 0.5);
                        }
                        
                        result += layerWeight * layerValue;
                        totalWeight += layerWeight;
                        layerWeight *= depth;
                    }
                    
                    result /= totalWeight;
                    result = pow(result, voronoiContrast);
                    return result;
                }

                vec3 getLightPosition(int index, float time) {
                    float angle = float(index) * (2.0 * PI / float(lightCount)) + time * lightSpeed;
                    float radius = 1.5;
                    float height = sin(time * lightSpeed * 0.5 + float(index)) * 0.5;
                    return vec3(radius * cos(angle), height, radius * sin(angle));
                }
                
                vec3 channel_mix(vec3 a, vec3 b, vec3 w) {
                    return vec3(mix(a.r, b.r, w.r), mix(a.g, b.g, w.g), mix(a.b, b.b, w.b));
                }
                
                float gaussian(float z, float u, float o) {
                    return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o))));
                }
                
                vec3 screen(vec3 a, vec3 b, float w) {
                    return mix(a, vec3(1.0) - (vec3(1.0) - a) * (vec3(1.0) - b), w);
                }
                
                vec3 overlay(vec3 a, vec3 b, float w) {
                    return mix(a, channel_mix(
                        2.0 * a * b,
                        vec3(1.0) - 2.0 * (vec3(1.0) - a) * (vec3(1.0) - b),
                        step(vec3(0.5), a)
                    ), w);
                }
                
                vec3 soft_light(vec3 a, vec3 b, float w) {
                    return mix(a, pow(a, pow(vec3(2.0), 2.0 * (vec3(0.5) - b))), w);
                }
                
                vec3 applyGrain(vec3 color, float noiseValue, float intensity) {
                    vec3 grain = vec3(noiseValue) * (1.0 - color);
                    
                    if (grainBlendMode == 0) {
                        return color + grain * intensity;
                    } else if (grainBlendMode == 1) {
                        return screen(color, grain, intensity);
                    } else if (grainBlendMode == 2) {
                        return overlay(color, grain, intensity);
                    } else if (grainBlendMode == 3) {
                        return soft_light(color, grain, intensity);
                    } else if (grainBlendMode == 4) {
                        return max(color, grain * intensity);
                    }
                    return color;
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / iResolution.xy;
                    float shape = 0.0;
                    vec2 effectUV = uv;
                    
                    if (effectType == 0) {
                        vec2 p = (effectUV * 2.0 - 1.0);
                        p.x *= iResolution.x / iResolution.y;
                        p *= fractalScale;
                        p += fractalOffset;
                        float d = length(p);
                        float pulse = 0.5 + 0.1 * sin(iTime * animationSpeed * 2.0);
                        float orbshape = smoothstep(pulse, pulse - 0.1, d);
                        float innerGlow = smoothstep(pulse * 0.8, 0.0, d) * 0.5;
                        float angle = atan(p.y, p.x);
                        float swirl = 0.15 * sin(angle * 8.0 + iTime * 3.0 * animationSpeed) * smoothstep(pulse, 0.0, d);
                        shape = orbshape + innerGlow + swirl;
                    } 
                    else if (effectType == 1) {
                        vec2 p = effectUV * perlinScale;
                        if (autoRotate > 0.5) {
                            float timeScale = iTime * animationSpeed;
                            p += vec2(
                                sin(timeScale * 0.5) * 0.3 + timeScale * 0.1,
                                cos(timeScale * 0.7) * 0.2 + timeScale * 0.05
                            );
                        }
                        vec2 mousePos = smoothedMouse / iResolution.xy;
                        mousePos = (mousePos * 2.0 - 1.0);
                        mousePos.x *= iResolution.x / iResolution.y;
                        if (mouseDown > 0.5) {
                            float mouseDist = length(p - mousePos * perlinScale);
                            float mouseInfluence = exp(-mouseDist * 5.0) * 0.2;
                            p += mousePos * mouseInfluence;
                        }
                        bool useRidges = perlinRidges > 0.5;
                        float terrain = enhancedFbm(p, perlinLayers, 0.5, perlinWarp, useRidges);
                        vec2 detailP = p * 2.0 + vec2(43.2, 17.9);
                        float detail = enhancedFbm(detailP, perlinLayers + 1, 0.6, perlinWarp * 0.7, useRidges);
                        float heightFactor = smoothstep(0.3, 0.7, terrain);
                        terrain = mix(terrain, terrain * 0.8 + detail * 0.4, heightFactor);
                        float heightVariation = sin(p.x * 0.2) * cos(p.y * 0.2) * 0.1;
                        terrain += heightVariation;
                        float flow = sin(p.x * 10.0 + iTime * animationSpeed * 5.0) * 
                                     sin(p.y * 8.0 + iTime * animationSpeed * 3.0);
                        flow = smoothstep(0.7, 0.9, flow) * 0.15;
                        terrain *= perlinHeight;
                        float pulse = sin(iTime * animationSpeed * 2.0) * 0.1;
                        terrain += pulse * (1.0 - terrain);
                        float fog = smoothstep(0.4, 0.0, terrain) * 0.2 * 
                                   (0.5 + 0.5 * sin(iTime * animationSpeed));
                        terrain += fog + flow;
                        shape = terrain;
                    }
                    else if (effectType == 2) {
                        vec2 p = (effectUV * 2.0 - 1.0);
                        p.x *= iResolution.x / iResolution.y;
                        float dist = length(p);
                        float ripples = sin(dist * 15.0 - iTime * 2.0 * animationSpeed) * 0.5 + 0.5;
                        ripples *= smoothstep(1.0, 0.2, dist);
                        shape = ripples;
                    }
                    else if (effectType == 3) {
                        vec2 p = effectUV * voronoiScale * fractalScale;
                        if (autoRotate > 0.5) {
                            float timeScale = iTime * animationSpeed * voronoiSpeed;
                            p += vec2(
                                sin(timeScale * 0.3) * 0.2 + timeScale * 0.05,
                                cos(timeScale * 0.4) * 0.2 + timeScale * 0.03
                            );
                        }
                        vec2 mousePos = smoothedMouse / iResolution.xy;
                        mousePos = (mousePos * 2.0 - 1.0);
                        mousePos.x *= iResolution.x / iResolution.y;
                        if (mouseDown > 0.5) {
                            float mouseDist = length(p - mousePos * voronoiScale * fractalScale);
                            float mouseInfluence = exp(-mouseDist * 3.0) * 0.3;
                            p += mousePos * mouseInfluence;
                        }
                        bool showEdges = voronoiEdges > 0.5;
                        float pattern = organicVoronoi(p, voronoiLayers, voronoiWarp, voronoiDepth, showEdges);
                        float depth = fbm(p * 0.5, 3, 0.5);
                        float fog = smoothstep(0.4, 0.0, pattern) * 0.3 * (0.7 + 0.3 * sin(iTime * animationSpeed));
                        float pulse = sin(iTime * animationSpeed * 1.5) * 0.1;
                        float glow = smoothstep(0.6, 0.0, pattern) * pulse;
                        float flow = 0.0;
                        if (showEdges) {
                            flow = sin(p.x * 5.0 + iTime * animationSpeed * 3.0) * 
                                   sin(p.y * 5.0 + iTime * animationSpeed * 2.0);
                            flow = smoothstep(0.7, 0.9, flow) * 0.2 * pattern;
                        }
                        pattern = mix(pattern, pattern * 0.8 + depth * 0.3, 0.4);
                        pattern += fog + glow + flow;
                        pattern = pow(pattern, 1.2);
                        shape = pattern;
                    }
                    else if (effectType == 4) {
                        vec2 p = effectUV * 2.0 - 1.0;
                        p.x *= iResolution.x / iResolution.y;
                        p *= fractalScale;
                        p += fractalOffset;
                        float angle = atan(p.y, p.x);
                        float dist = length(p);
                        float segmentAngle = 2.0 * PI / float(kaleidoscopeSegments);
                        angle = mod(angle, segmentAngle);
                        angle = min(angle, segmentAngle - angle);
                        vec2 kUV = vec2(cos(angle), sin(angle)) * dist;
                        kUV += 0.1 * sin(dist * 10.0 - iTime * animationSpeed * 2.0);
                        float pattern = 0.5 + 0.5 * sin(kUV.x * 10.0) * sin(kUV.y * 10.0);
                        pattern *= smoothstep(1.0, 0.8, dist);
                        shape = pattern;
                    }
                    else if (effectType == 5) {
                        vec2 p = effectUV * 2.0 - 1.0;
                        p.x *= iResolution.x / iResolution.y;
                        p *= fractalScale;
                        p += fractalOffset;
                        float dist = length(p);
                        float carrierFreq = fmDensity;
                        float modFreq = fmDensity * 0.5;
                        float modIndex = fmIntensity * 5.0;
                        float carrierTime = iTime * animationSpeed;
                        float modTime = iTime * animationSpeed * 0.7;
                        float modulator = sin(p.x * modFreq + modTime) * sin(p.y * modFreq + modTime) * modIndex;
                        float signal = sin(p.x * carrierFreq + modulator + carrierTime) * 
                                      sin(p.y * carrierFreq + modulator + carrierTime);
                        signal = 0.5 + 0.5 * signal;
                        signal *= smoothstep(1.0, 0.5, dist);
                        shape = signal;
                    }
                    else if (effectType == 6) {
                        vec2 c = vec2(
                            0.7885 * cos(iTime * animationSpeed * 0.4),
                            0.7885 * sin(iTime * animationSpeed * 0.4)
                        );
                        vec2 z = (uv * 2.0 - 1.0) * 1.5;
                        z.x *= iResolution.x / iResolution.y;
                        z *= fractalScale;
                        z += fractalOffset;
                        float iteration = 0.0;
                        
                        for (int i = 0; i < 100; i++) {
                            if (i >= fractionalIterations) break;
                            z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                            if (dot(z, z) > 4.0) break;
                            iteration += 1.0;
                        }
                        
                        if (iteration < float(fractionalIterations)) {
                            float log_zn = log(dot(z, z)) * 0.5;
                            float smoothed = iteration + 1.0 - log(log_zn / log(2.0)) / log(2.0);
                            iteration = smoothed;
                        }
                        shape = iteration / float(fractionalIterations);
                    }
                    else if (effectType == 7) {
                        vec2 p = (uv * 2.0 - 1.0);
                        p.x *= iResolution.x / iResolution.y;
                        p *= fractalScale * 2.0;
                        p += fractalOffset;
                        vec2 grid = fract(p * waveFrequency) - 0.5;
                        float waves = 0.0;
                        waves += sin(p.x * 5.0 + iTime * animationSpeed * 2.0) * waveAmplitude;
                        waves += sin(p.y * 5.0 + iTime * animationSpeed * 2.0) * waveAmplitude;
                        waves += sin((p.x + p.y) * 4.0 + iTime * animationSpeed * 3.0) * waveAmplitude;
                        waves += sin((p.x - p.y) * 4.0 + iTime * animationSpeed * 3.0) * waveAmplitude;
                        float gridLines = max(
                            smoothstep(0.05, 0.0, abs(grid.x) - (0.1 + waves * 0.1)),
                            smoothstep(0.05, 0.0, abs(grid.y) - (0.1 + waves * 0.1))
                        );
                        gridLines *= 0.8 + 0.2 * sin(iTime * animationSpeed * 5.0);
                        shape = gridLines;
                    }
                    
                    vec2 centeredUV = (uv * 2.0 - 1.0);
                    centeredUV.x *= iResolution.x / iResolution.y;
                    vec3 pos = vec3(centeredUV.x, centeredUV.y, 0.0);
                    float totalLight = 0.0;
                    
                    for (int i = 0; i < 10; i++) {
                        if (i >= lightCount) break;
                        vec3 lightPos = getLightPosition(i, iTime);
                        float dist = length(pos - lightPos);
                        totalLight += lightIntensity / (1.0 + dist * dist * 2.0);
                    }
                    
                    vec2 mousePos = smoothedMouse / iResolution.xy;
                    mousePos = (mousePos * 2.0 - 1.0);
                    mousePos.x *= iResolution.x / iResolution.y;
                    float mouseDist = length(centeredUV - mousePos);
                    totalLight += lightIntensity * 2.0 / (1.0 + mouseDist * mouseDist * 4.0);
                    totalLight += 0.2;
                    
                    if (useBloom > 0.5) {
                        totalLight *= lightBloomBalance;
                    }
                    
                    vec3 finalColor = mix(primaryColor, secondaryColor, shape);
                    float highlight = pow(shape, 3.0);
                    finalColor = mix(finalColor, accentColor, highlight * 0.5);
                    finalColor *= totalLight * (shape + 0.2);
                    
                    float t = iTime * grainSpeed * animationSpeed;
                    float seed = dot(vUv, vec2(12.9898, 78.233));
                    float noise = fract(sin(seed) * 43758.5453 + t);
                    noise = gaussian(noise, grainMean, grainVariance * grainVariance);
                    finalColor = applyGrain(finalColor, noise, grainStrength);
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        // Create a fullscreen plane
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), shaderMaterial);
        scene.add(plane);

        // Setup post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Add bloom effect
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            params.bloomStrength,
            params.bloomRadius,
            params.bloomThreshold
        );
        composer.addPass(bloomPass);

        // Dropdown functionality
        const colorThemeToggle = document.getElementById('colorThemeToggle');
        const colorThemeMenu = document.getElementById('colorThemeMenu');
        const effectTypeToggle = document.getElementById('effectTypeToggle');
        const effectTypeMenu = document.getElementById('effectTypeMenu');

        // Toggle dropdowns
        colorThemeToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            colorThemeMenu.classList.toggle('show');
            colorThemeToggle.parentElement.classList.toggle('active');
            effectTypeMenu.classList.remove('show');
            effectTypeToggle.parentElement.classList.remove('active');
        });

        effectTypeToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            effectTypeMenu.classList.toggle('show');
            effectTypeToggle.parentElement.classList.toggle('active');
            colorThemeMenu.classList.remove('show');
            colorThemeToggle.parentElement.classList.remove('active');
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', () => {
            colorThemeMenu.classList.remove('show');
            effectTypeMenu.classList.remove('show');
            colorThemeToggle.parentElement.classList.remove('active');
            effectTypeToggle.parentElement.classList.remove('active');
        });

        // Color theme selection
        const colorThemeItems = document.querySelectorAll('#colorThemeMenu .dropdown-item');
        colorThemeItems.forEach(item => {
            item.addEventListener('click', () => {
                const themeName = item.getAttribute('data-theme');
                const preset = colorPresets[themeName];
                
                // Update active state
                colorThemeItems.forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                
                // Update params
                params.primaryColor = [...preset.primaryColor];
                params.secondaryColor = [...preset.secondaryColor];
                params.accentColor = [...preset.accentColor];
                
                // Update shader uniforms
                shaderMaterial.uniforms.primaryColor.value.fromArray(
                    preset.primaryColor.map((c) => c / 255)
                );
                shaderMaterial.uniforms.secondaryColor.value.fromArray(
                    preset.secondaryColor.map((c) => c / 255)
                );
                shaderMaterial.uniforms.accentColor.value.fromArray(
                    preset.accentColor.map((c) => c / 255)
                );
            });
        });

        // Effect type selection
        const effectTypeItems = document.querySelectorAll('#effectTypeMenu .dropdown-item');
        effectTypeItems.forEach(item => {
            item.addEventListener('click', () => {
                const effectValue = parseInt(item.getAttribute('data-effect'));
                const effectName = item.textContent;
                
                // Update active state
                effectTypeItems.forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                
                // Update effect type
                params.effectType = effectValue;
                shaderMaterial.uniforms.effectType.value = effectValue;
            });
        });

        // Mouse event listeners
        window.addEventListener("mousemove", (event) => {
            const mouseX = event.clientX / window.innerWidth;
            const mouseY = 1.0 - event.clientY / window.innerHeight;
            mouse.set(mouseX, mouseY);
        });

        window.addEventListener("mousedown", () => {
            mouseDown = true;
            shaderMaterial.uniforms.mouseDown.value = 1.0;
        });

        window.addEventListener("mouseup", () => {
            mouseDown = false;
            shaderMaterial.uniforms.mouseDown.value = 0.0;
        });

        // Animation Loop
        function animate() {
            const time = performance.now() * 0.001;
            shaderMaterial.uniforms.iTime.value = time;

            smoothedMouse.lerp(mouse, 0.1);
            shaderMaterial.uniforms.smoothedMouse.value.set(
                smoothedMouse.x * window.innerWidth,
                smoothedMouse.y * window.innerHeight
            );

            if (params.useBloom) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }

            requestAnimationFrame(animate);
        }

        animate();

        // Handle Window Resize
        window.addEventListener("resize", () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            renderer.setSize(width, height);
            composer.setSize(width, height);
            shaderMaterial.uniforms.iResolution.value.set(width, height);
        });

        // Touch support
        window.addEventListener("touchmove", (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            const mouseX = touch.clientX / window.innerWidth;
            const mouseY = 1.0 - touch.clientY / window.innerHeight;
            mouse.set(mouseX, mouseY);
        }, { passive: false });

        window.addEventListener("touchstart", (event) => {
            mouseDown = true;
            shaderMaterial.uniforms.mouseDown.value = 1.0;
            const touch = event.touches[0];
            const mouseX = touch.clientX / window.innerWidth;
            const mouseY = 1.0 - touch.clientY / window.innerHeight;
            mouse.set(mouseX, mouseY);
        });

        window.addEventListener("touchend", () => {
            mouseDown = false;
            shaderMaterial.uniforms.mouseDown.value = 0.0;
        });
    </script>
</body>
</html>
